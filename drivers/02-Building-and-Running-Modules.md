### 安全问题
系统中的所有安全检查都是由内核代码进行的，如果内核有安全漏洞，则整个系统就会有安全漏洞。
在正式发行的内核版本中，只有授权用户才能装载模块；也就是说，系统调用init_module会检查调用进程
是否具有将模块装载到内核的权利。因此运行正式发布的内核时，只有超级用户啊或者成功成为超级用户的
入侵者才能使用特权代码。

驱动程序编写者应当尽量避免在代码中实现安全策略，安全策略最好在系统管理员的控制之下，由内核的高层来实现。
### 版本编号
对内核来讲，偶数编号的内核版本(如2.6.x)是用于正式发行的稳定版本，而奇数编号的版本(如2.7.x)则是开发
过程中的一个快照，它将很快被下一开发版本更新。
### 用户空间和内核空间
模块运行在所谓的内核空间里,而应用程序运行在所谓的用户空间中。

应用程序在虚拟内存中布局,并具有一块很大的栈空间，相反的是，内核具有非常小的栈，它可能只和一个4096字节大小的页那样小。我们自己的函数必须和整个内核空间调用链一同共享这个栈，因此，声明大的自动变量并不是一个好主意，如果需要大的结构，则应该在调用时动态分配该结构。
### 编译模块
在构造内核模块之前，应确保具备了正确版本的编译器、模块工具和其他必要的工具。内核文档目录中的Documentation/Changes文件列出了需要的工具版本；如果利用错误的工具版本来构造内核（及其模块），将导致许多细微的、复杂的问题。另外需要注意，和使用老工具一样，使用太新的工具也偶尔会导致问题；内核源代码对编译器做了大量假定，因此新的编译器版本可能导致问题的出现。

单个文件生成模块hello.ko
```make
obj-m := hello.o
```
多个文件生成模块module.ko
```make
obj-m := module.o
module-objs := file1.o file2.o
```
以上Makefile构造模块必须在内核构造系统环境中调用才可以成功编译；内核树之外构造模块的方法如下：
```make
ifneq ($(KERNELRELEASE),)
	obj-m := hello.o

else
	KERNELDIR ?= /lib/modules/$(shell uname -r)/build
	PWD := $(shell pwd)

default:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules

endif
```
### 内核符号表
insmod使用公共内核符号表来解析模块中未定义的符号，公共内核符号表中包含了所有的全局内核项（即函数和变量）的地址。一个模块可以导出自己的符号，这样，我们可以在其他模块上层叠出新的模块。模块层叠技术在复杂的项目中非常有用。在通常情况下，模块只需实现自己的功能，而无需导出任何符号。

如果一个模块需要向其他模块导出符号，则应该使用下面的宏：
```c
EXPORT_SYMBOL(name)
//只能被GPL许可证下的模块使用
EXPORT_SYMBOL_GPL(name)
```
### 预备知识
所有可装载模块代码中都包含下面两行代码：
```c
#include <linux/module.h>
#include <linux/init.h>
```
指定代码所使用的许可证（不是严格要求）：
```c
MODULE_LICENSE("GPL")
```

**MODULE_**声明可以出现在源文件中源代码以外的任何地方，但内核编码习惯是将这些声明放在文件最后。

### 初始化和关闭
初始化和退出函数应该被声明为static，因为这种函数在特定文件之外没有其他意义；可以在这两个函数前适当的加 **__init** 和 **__exit**。
### 模块参数
### 在用户空间编写驱动程序
